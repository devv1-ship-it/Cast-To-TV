<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Cast To TV - WebRTC Screen Mirroring</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
        }
        #video-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }
        #remoteVideo {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #000;
        }
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 1000;
        }
        #stats {
            position: absolute;
            top: 60px;
            left: 20px;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="status">Initializing WebRTC...</div>
    <div id="stats">Waiting for connection...</div>
    <div id="video-container">
        <video id="remoteVideo" autoplay playsinline></video>
    </div>

    <script src="https://www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
    <script>
        const context = cast.framework.CastReceiverContext.getInstance();
        const statusEl = document.getElementById('status');
        const statsEl = document.getElementById('stats');
        const remoteVideo = document.getElementById('remoteVideo');

        const NAMESPACE = 'urn:x-cast:com.xxx.screenmirroring';

        // WebRTC variables
        let peerConnection = null;
        let statsInterval = null;
        let lastBytesReceived = 0;
        let lastTimestamp = Date.now();

        console.log('=== WebRTC Cast Receiver Initializing ===');

        // Initialize Cast Receiver with optimizations
        const castReceiverOptions = new cast.framework.CastReceiverOptions();
        castReceiverOptions.disableIdleTimeout = true;
        castReceiverOptions.maxInactivity = 3600;

        // Handle WebRTC signaling messages
        context.addCustomMessageListener(NAMESPACE, function(customEvent) {
            try {
                const data = customEvent.data;
                console.log('Received message type:', data.type);

                if (data.type === 'offer') {
                    handleOffer(data);
                } else if (data.type === 'ice_candidate') {
                    handleIceCandidate(data);
                }
            } catch (error) {
                console.error('Error processing message:', error);
                statusEl.textContent = 'Error: ' + error.message;
            }
        });

        async function handleOffer(data) {
            try {
                console.log('Handling offer from sender');
                statusEl.textContent = 'ðŸ“¡ Setting up WebRTC connection...';

                // Create peer connection with optimized settings
                const configuration = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' }
                    ],
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require',
                    iceTransportPolicy: 'all'
                };

                peerConnection = new RTCPeerConnection(configuration);
                console.log('PeerConnection created');

                // Handle incoming tracks (video + audio)
                peerConnection.ontrack = (event) => {
                    console.log('âœ“ Received track:', event.track.kind, 'id:', event.track.id, 'readyState:', event.track.readyState);
                    console.log('Streams count:', event.streams.length);
                    
                    if (event.streams && event.streams[0]) {
                        console.log('Setting srcObject to video element');
                        remoteVideo.srcObject = event.streams[0];
                        
                        // Set volume to maximum
                        remoteVideo.volume = 1.0;
                        
                        // Force play
                        remoteVideo.play().then(() => {
                            console.log('âœ“âœ“âœ“ Video playback started successfully!');
                            statusEl.textContent = 'âœ… Screen Mirroring Active';
                            
                            // Log video element state
                            console.log('Video element state:', {
                                paused: remoteVideo.paused,
                                muted: remoteVideo.muted,
                                volume: remoteVideo.volume,
                                videoWidth: remoteVideo.videoWidth,
                                videoHeight: remoteVideo.videoHeight,
                                readyState: remoteVideo.readyState
                            });
                            
                            startStatsMonitoring();
                        }).catch(err => {
                            console.error('âœ— Error starting video playback:', err);
                            statusEl.textContent = 'Error playing video: ' + err.message;
                        });
                    } else {
                        console.warn('No streams in track event!');
                    }
                };

                // Handle ICE connection state
                peerConnection.oniceconnectionstatechange = () => {
                    console.log('ICE Connection State:', peerConnection.iceConnectionState);
                    const state = peerConnection.iceConnectionState;
                    
                    if (state === 'connected' || state === 'completed') {
                        console.log('âœ“ ICE connected!');
                        statusEl.textContent = 'âœ… Connected - Waiting for video...';
                    } else if (state === 'disconnected') {
                        statusEl.textContent = 'âš ï¸ Connection lost';
                    } else if (state === 'failed') {
                        statusEl.textContent = 'âŒ Connection failed';
                        console.error('ICE connection failed');
                        stopStatsMonitoring();
                    } else if (state === 'checking') {
                        statusEl.textContent = 'ðŸ”„ Connecting...';
                    }
                };

                // Handle connection state
                peerConnection.onconnectionstatechange = () => {
                    console.log('Connection State:', peerConnection.connectionState);
                };

                // Handle ICE candidates
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log('Generated ICE candidate:', event.candidate.type);
                        sendIceCandidate(event.candidate);
                    } else {
                        console.log('ICE gathering complete');
                    }
                };

                // Set remote description (offer)
                console.log('Setting remote description...');
                await peerConnection.setRemoteDescription({
                    type: 'offer',
                    sdp: data.sdp
                });
                console.log('âœ“ Remote description set');

                // Create answer
                console.log('Creating answer...');
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                console.log('âœ“ Local description (answer) set');

                // Send answer back to sender
                sendAnswer(answer);

            } catch (error) {
                console.error('âœ— Error handling offer:', error);
                statusEl.textContent = 'Error: ' + error.message;
            }
        }

        async function handleIceCandidate(data) {
            try {
                if (peerConnection) {
                    await peerConnection.addIceCandidate({
                        candidate: data.candidate,
                        sdpMid: data.sdpMid,
                        sdpMLineIndex: data.sdpMLineIndex
                    });
                    console.log('âœ“ Added ICE candidate from sender');
                }
            } catch (error) {
                console.error('Error adding ICE candidate:', error);
            }
        }

        function sendAnswer(answer) {
            try {
                const message = JSON.stringify({
                    type: 'answer',
                    sdp: answer.sdp
                });
                context.sendCustomMessage(NAMESPACE, undefined, message);
                console.log('âœ“ Sent WebRTC answer to sender');
            } catch (error) {
                console.error('Error sending answer:', error);
            }
        }

        function sendIceCandidate(candidate) {
            try {
                const message = JSON.stringify({
                    type: 'ice_candidate',
                    candidate: candidate.candidate,
                    sdpMid: candidate.sdpMid,
                    sdpMLineIndex: candidate.sdpMLineIndex
                });
                context.sendCustomMessage(NAMESPACE, undefined, message);
            } catch (error) {
                console.error('Error sending ICE candidate:', error);
            }
        }

        function startStatsMonitoring() {
            if (statsInterval) return;

            statsInterval = setInterval(async () => {
                if (!peerConnection) return;

                try {
                    const stats = await peerConnection.getStats();
                    let fps = 0;
                    let bitrate = 0;
                    let resolution = '';
                    let packetsLost = 0;

                    stats.forEach(report => {
                        if (report.type === 'inbound-rtp' && report.mediaType === 'video') {
                            fps = report.framesPerSecond || 0;
                            packetsLost = report.packetsLost || 0;
                            
                            // Calculate bitrate
                            const now = Date.now();
                            const timeDiff = (now - lastTimestamp) / 1000;
                            const bytesDiff = (report.bytesReceived || 0) - lastBytesReceived;
                            bitrate = Math.round((bytesDiff * 8) / timeDiff / 1000); // Kbps
                            
                            lastBytesReceived = report.bytesReceived || 0;
                            lastTimestamp = now;
                        }
                        if (report.type === 'track' && report.kind === 'video') {
                            resolution = `${report.frameWidth}x${report.frameHeight}`;
                        }
                    });

                    statsEl.innerHTML = `FPS: ${fps.toFixed(0)} | ${bitrate} Kbps | ${resolution}<br>Lost: ${packetsLost} packets`;
                } catch (error) {
                    console.error('Error getting stats:', error);
                }
            }, 1000);
        }

        function stopStatsMonitoring() {
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
        }

        // System events
        context.addEventListener(cast.framework.system.EventType.SENDER_CONNECTED, function(event) {
            console.log('âœ“ Sender connected:', event.senderId);
            statusEl.textContent = 'Device Connected - Waiting for stream...';
        });

        context.addEventListener(cast.framework.system.EventType.SENDER_DISCONNECTED, function(event) {
            console.log('Sender disconnected');
            statusEl.textContent = 'Device Disconnected';
            statsEl.textContent = '';
            remoteVideo.srcObject = null;

            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            stopStatsMonitoring();
        });

        context.addEventListener(cast.framework.system.EventType.READY, function(event) {
            console.log('âœ“ Receiver ready');
            statusEl.textContent = 'Ready - Waiting for connection...';
        });

        // Start receiver
        try {
            context.start(castReceiverOptions);
            console.log('=== âœ“âœ“âœ“ WebRTC Cast receiver started successfully ===');
        } catch (error) {
            console.error('=== âœ—âœ—âœ— FAILED to start receiver ===', error);
            statusEl.textContent = 'FAILED: ' + error.message;
            document.body.style.backgroundColor = '#ff0000';
        }
    </script>
</body>
</html>
