<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>DEBUG MODE - WebRTC Receiver</title>
    <style>
        body { margin: 0; background-color: #111; color: white; font-family: 'Courier New', monospace; }
        #status {
            position: absolute; top: 20px; left: 20px; font-size: 2em;
            background: rgba(0,0,0,0.8); padding: 10px; border-radius: 5px; z-index: 100;
        }
        #error-display {
            position: absolute; top: 100px; left: 20px; font-size: 1.5em; color: red;
            background: rgba(0,0,0,0.8); padding: 10px; border-radius: 5px; z-index: 100;
        }
    </style>
</head>
<body>
<div id="status">Step 1: Initializing...</div>
<div id="error-display"></div>
<video id="remoteVideo" autoplay playsinline style="width:100vw; height:100vh; object-fit:contain;"></video>

<script src="https://www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
<script>
    const statusEl = document.getElementById('status');
    const errorEl = document.getElementById('error-display');
    const remoteVideo = document.getElementById('remoteVideo');
    const NAMESPACE = 'urn:x-cast:com.xxx.screenmirroring';
    let peerConnection = null;
    let context = null;

    function updateStatus(message) {
        console.log(message);
        statusEl.textContent = message;
    }

    function displayError(step, error) {
        const errorMessage = `FAIL @ ${step}: ${error.message}`;
        console.error(errorMessage, error.stack);
        errorEl.textContent = errorMessage;
        document.body.style.backgroundColor = '#500'; // Dark red background on error
    }

    try {
        updateStatus('Step 2: Getting Cast Context...');
        context = cast.framework.CastReceiverContext.getInstance();
        const castReceiverOptions = new cast.framework.CastReceiverOptions();
        castReceiverOptions.disableIdleTimeout = true;
        castReceiverOptions.maxInactivity = 3600;

        updateStatus('Step 3: Adding Message Listener...');
        context.addCustomMessageListener(NAMESPACE, function(customEvent) {
            try {
                updateStatus('Step 6: Message Received (type: ' + customEvent.data.type + ')');
                let data = customEvent.data;

                // Handle both string and object data
                if (typeof data === 'string') {
                    data = JSON.parse(data);
                }

                if (data.type === 'offer') {
                    handleOffer(data);
                } else if (data.type === 'ice_candidate') {
                    handleIceCandidate(data);
                }
            } catch (e) {
                displayError('Processing Message', e);
            }
        });

        updateStatus('Step 4: Adding Event Listeners...');
        context.addEventListener(cast.framework.system.EventType.READY, () => {
            updateStatus('Step 5: ✅ READY - Waiting for Connection!');
            document.body.style.backgroundColor = '#004400'; // Dark green = success
        });

        context.addEventListener(cast.framework.system.EventType.SENDER_CONNECTED, (event) => {
            updateStatus('✅ Sender Connected! Waiting for WebRTC...');
            console.log('Sender ID:', event.senderId);
        });

        context.addEventListener(cast.framework.system.EventType.SENDER_DISCONNECTED, () => {
            updateStatus('Sender Disconnected.');
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            remoteVideo.srcObject = null;
        });

        // FIXED: context.start() is synchronous, doesn't return a Promise
        updateStatus('Step 4b: Starting Cast Context...');
        context.start(castReceiverOptions);
        updateStatus('Step 5: Cast Context Started Successfully!');

    } catch (e) {
        displayError('Global Init', e);
    }

    async function handleOffer(data) {
        try {
            updateStatus('Step 7: Handling Offer...');
            console.log('Offer SDP length:', data.sdp ? data.sdp.length : 'missing');

            const configuration = {
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require'
            };
            peerConnection = new RTCPeerConnection(configuration);
            console.log('PeerConnection created');

            // CRITICAL: Set up track handler BEFORE setting remote description
            peerConnection.ontrack = (event) => {
                updateStatus('Step 11: ✅ Track Received! Kind: ' + event.track.kind);
                console.log('Track kind:', event.track.kind, 'Streams:', event.streams.length);
                console.log('Track ID:', event.track.id, 'Track state:', event.track.readyState);

                if (event.streams && event.streams[0]) {
                    console.log('Setting srcObject... Stream ID:', event.streams[0].id);
                    
                    // Set srcObject immediately for the first track
                    if (!remoteVideo.srcObject) {
                        remoteVideo.srcObject = event.streams[0];
                        console.log('✓ srcObject set for the first time');
                    } else if (remoteVideo.srcObject.id !== event.streams[0].id) {
                        // Update if it's a different stream
                        remoteVideo.srcObject = event.streams[0];
                        console.log('✓ srcObject updated with new stream');
                    }
                    
                    remoteVideo.volume = 1.0;

                    remoteVideo.play().then(() => {
                        updateStatus('✅✅✅ VIDEO PLAYING!');
                        document.body.style.backgroundColor = '#006600'; // Bright green = video playing
                        console.log('Video state:', {
                            paused: remoteVideo.paused,
                            videoWidth: remoteVideo.videoWidth,
                            videoHeight: remoteVideo.videoHeight,
                            volume: remoteVideo.volume,
                            readyState: remoteVideo.readyState,
                            networkState: remoteVideo.networkState
                        });
                    }).catch(e => {
                        console.error('Play error:', e);
                        displayError('Video Play', e);
                    });
                } else {
                    console.warn('No streams in track event!');
                }
            };

            // Log when tracks are added
            peerConnection.addEventListener('track', (e) => {
                console.log('TRACK EVENT FIRED!', e.track.kind);
            });

            peerConnection.oniceconnectionstatechange = () => {
                console.log('ICE Connection State:', peerConnection.iceConnectionState);
                if (peerConnection.iceConnectionState === 'connected') {
                    updateStatus('Step 12: ✅ ICE CONNECTED!');
                    
                    // Check if we have tracks
                    const receivers = peerConnection.getReceivers();
                    console.log('Total receivers:', receivers.length);
                    receivers.forEach((receiver, index) => {
                        console.log(`Receiver ${index}:`, receiver.track ? receiver.track.kind : 'no track');
                    });
                }
            };

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('Sending ICE candidate to sender');
                    sendMessage({
                        type: 'ice_candidate',
                        candidate: event.candidate.candidate,
                        sdpMid: event.candidate.sdpMid,
                        sdpMLineIndex: event.candidate.sdpMLineIndex
                    });
                } else {
                    console.log('ICE gathering complete');
                }
            };

            updateStatus('Step 8: Setting Remote Description...');
            await peerConnection.setRemoteDescription(new RTCSessionDescription({
                type: 'offer',
                sdp: data.sdp
            }));
            console.log('✓ Remote description set');
            
            // Log transceivers after setting remote description
            const transceivers = peerConnection.getTransceivers();
            console.log('Transceivers count:', transceivers.length);
            transceivers.forEach((transceiver, index) => {
                console.log(`Transceiver ${index}:`, {
                    mid: transceiver.mid,
                    direction: transceiver.direction,
                    currentDirection: transceiver.currentDirection,
                    receiver: transceiver.receiver.track ? transceiver.receiver.track.kind : 'no track'
                });
            });

            updateStatus('Step 9: Creating Answer...');
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            console.log('✓ Local description set');

            updateStatus('Step 10: Sending Answer...');
            sendMessage({ type: 'answer', sdp: answer.sdp });
            console.log('✓ Answer sent');
            
            // Force check for tracks after a short delay
            setTimeout(() => {
                const receivers = peerConnection.getReceivers();
                console.log('Delayed check - Receivers:', receivers.length);
                receivers.forEach((receiver, index) => {
                    if (receiver.track) {
                        console.log(`Delayed track found ${index}:`, receiver.track.kind, 'state:', receiver.track.readyState);
                        // If track exists but wasn't fired via ontrack, manually trigger it
                        if (remoteVideo.srcObject === null && receiver.track.readyState === 'live') {
                            console.warn('Track exists but ontrack not fired! Manually setting...');
                            const stream = new MediaStream([receiver.track]);
                            remoteVideo.srcObject = stream;
                            remoteVideo.volume = 1.0;
                            remoteVideo.play().then(() => {
                                updateStatus('✅✅✅ VIDEO PLAYING (manual)!');
                                document.body.style.backgroundColor = '#006600';
                            }).catch(e => console.error('Manual play error:', e));
                        }
                    }
                });
            }, 2000);

        } catch (e) {
            displayError('Handle Offer', e);
        }
    }

    async function handleIceCandidate(data) {
        try {
            if (peerConnection && data.candidate) {
                console.log('Adding ICE candidate from sender');
                await peerConnection.addIceCandidate(new RTCIceCandidate({
                    candidate: data.candidate,
                    sdpMid: data.sdpMid,
                    sdpMLineIndex: data.sdpMLineIndex
                }));
                console.log('✓ ICE candidate added');
            }
        } catch (e) {
            displayError('Handle ICE', e);
        }
    }

    function sendMessage(messageObject) {
        try {
            const messageStr = JSON.stringify(messageObject);
            console.log('Sending message:', messageObject.type, 'Length:', messageStr.length);
            context.sendCustomMessage(NAMESPACE, undefined, messageStr);
            console.log('✓ Message sent');
        } catch (e) {
            displayError('Send Message', e);
        }
    }
</script>
</body>
</html>
