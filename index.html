<!--THIS FILE IS UPLOADED TO SERVER AND PUBLISHED-->
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebRTC Screen Mirroring</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            color: white;
            font-family: Arial, sans-serif;
        }

        #remoteVideo,
        #youtubePlayer {
            width: 100vw;
            height: 100vh;
            object-fit: contain;
            background: #000;
            position: absolute;
            top: 0;
            left: 0;
        }

        #youtubePlayer { display: none; }

        /* Image display */
        #imageDisplay {
            width: 100vw;
            height: 100vh;
            object-fit: contain;
            background: #000;
            position: absolute;
            top: 0;
            left: 0;
            display: none;
            z-index: 10;
        }

        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.2em;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 100;
        }

        /* Audio visualization overlay */
        #audio-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 50;
        }

        #audio-overlay.active {
            display: flex;
        }

        .audio-icon {
            width: 200px;
            height: 200px;
            margin-bottom: 30px;
            animation: pulse 2s ease-in-out infinite;
        }

        .audio-title {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
            padding: 0 40px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .audio-info {
            font-size: 1.5em;
            opacity: 0.9;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        /* CSS FOR THE ON-SCREEN LOGGER */
        #debug-log-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 80%;
            height: 50%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-family: monospace;
            font-size: 14px;
            padding: 10px;
            z-index: 9999;
            overflow-y: scroll;
            border: 1px solid #555;
            display: block;
        }
        .log-msg { margin: 0; padding: 2px 0; border-bottom: 1px solid #333; }
        .log-error { color: #ff6b6b; }
        .log-warn { color: #ffd966; }
    </style>
</head>
<body>
<!-- HTML ELEMENT FOR THE LOGGER -->
<div id="debug-log-overlay"></div>

<div id="status">Connecting...</div>
<video id="remoteVideo" autoplay playsinline muted="false"></video>
<div id="youtubePlayer"></div>
<img id="imageDisplay" src="" alt="Cast Image" />
<div id="audio-overlay">
    <div class="audio-icon">ðŸ”Š</div>
    <div class="audio-title">Audio Streaming</div>
    <div class="audio-info">Now playing audio content</div>
</div>

<!-- This must be the first script to run -->
<script>
    // JAVASCRIPT FOR THE ON-SCREEN LOGGER
    (function () {
        const logContainer = document.getElementById('debug-log-overlay');
        if (!logContainer) return;

        function addLogMessage(message, className) {
            const p = document.createElement('p');
            p.textContent = message;
            p.className = 'log-msg ' + className;
            logContainer.appendChild(p);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        const originalConsole = {
            log: console.log.bind(console),
            error: console.error.bind(console),
            warn: console.warn.bind(console),
        };

        console.log = function(...args) {
            originalConsole.log(...args);
            const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : arg).join(' ');
            addLogMessage('LOG: ' + message, 'log-info');
        };
        console.error = function(...args) {
            originalConsole.error(...args);
            const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : arg).join(' ');
            addLogMessage('ERROR: ' + message, 'log-error');
        };
        console.warn = function(...args) {
            originalConsole.warn(...args);
            const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : arg).join(' ');
            addLogMessage('WARN: ' + message, 'log-warn');
        };

        window.onerror = function(message, source, lineno, colno, error) {
            const fullMessage = `Uncaught Exception: ${message} at ${source}:${lineno}:${colno}`;
            console.error(fullMessage, error);
            return true;
        };
    })();
</script>

<script src="https://www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
<script>
    // --- YOUR APPLICATION CODE ---
    const statusEl = document.getElementById('status');
    const remoteVideo = document.getElementById('remoteVideo');
    const youtubePlayerEl = document.getElementById('youtubePlayer');
    const audioOverlay = document.getElementById('audio-overlay');
    const NAMESPACE = 'urn:x-cast:com.xxx.screenmirroring';
    let peerConnection = null;
    let context = null;

    // Ensure video is not muted
    remoteVideo.muted = false;
    remoteVideo.volume = 1.0;

    // Audio playback components
    let audioContext = null;
    let audioQueue = [];
    let isPlayingAudio = false;
    let nextPlayTime = 0;

    try {
        console.log("Receiver script starting.");
        context = cast.framework.CastReceiverContext.getInstance();
        const castReceiverOptions = new cast.framework.CastReceiverOptions();
        castReceiverOptions.disableIdleTimeout = true;
        castReceiverOptions.maxInactivity = 3600;

        context.addCustomMessageListener(NAMESPACE, function(customEvent) {
            try {
                let data = customEvent.data;
                console.log("Received custom message:", data);
                if (typeof data === 'string') {
                    data = JSON.parse(data);
                }

                if (data.type === 'offer') {
                    // You need to define cleanupYouTube() and handleOffer()
                    handleOffer(data);
                } else if (data.type === 'ice_candidate') {
                    // You need to define handleIceCandidate()
                    handleIceCandidate(data);
                } else if (data.type === 'audio') {
                    handleAudioData(data);
                } else if (data.type === 'YOUTUBE') {
                    console.log('Received YOUTUBE message with videoId:', data.videoId);
                    loadYouTubeVideo(data.videoId);
                } else if (data.type === 'YT_COMMAND') {
                    console.log('[YT_CONTROL] Received YT_COMMAND:', data.command);
                    handleYouTubeCommand(data);
                } else if (data.type === 'SHOW_IMAGE') {
                    console.log('ðŸ“· Received SHOW_IMAGE message');
                    console.log('   URL:', data.url);
                    console.log('   Title:', data.title);
                    showImageFromCustomMessage(data);
                }
            } catch (e) {
                console.error('Message processing error:', e);
            }
        });

        context.addEventListener(cast.framework.system.EventType.READY, () => {
            statusEl.textContent = 'Ready';
            console.log('Receiver ready');
            initializeAudioContext();
        });

        context.addEventListener(cast.framework.system.EventType.SENDER_CONNECTED, (event) => {
            statusEl.textContent = 'Connected - Waiting for stream...';
            console.log('Sender connected:', event.senderId);
        });

        context.addEventListener(cast.framework.system.EventType.SENDER_DISCONNECTED, () => {
            statusEl.textContent = 'Disconnected';
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            remoteVideo.srcObject = null;
            stopAudioPlayback();
        });

        context.start(castReceiverOptions);
        console.log("CastReceiverContext started.");

        // Get the PlayerManager to handle media playback events
        const playerManager = context.getPlayerManager();

        // Listen for when media is loaded
        playerManager.setMessageInterceptor(
            cast.framework.messages.MessageType.LOAD,
            loadRequestData => {
                console.log('Media load request:', loadRequestData);
                const media = loadRequestData.media;
                if (media && media.contentType) {
                    console.log('Content type:', media.contentType);
                    // Check if it's audio content
                    if (media.contentType.startsWith('audio/')) {
                        console.log('Audio content detected - showing audio overlay');
                        showAudioOverlay(media);
                    } else {
                        hideAudioOverlay();
                    }
                }
                return loadRequestData;
            }
        );

        // Listen for player state changes
        playerManager.addEventListener(
            cast.framework.events.EventType.PLAYER_LOAD_COMPLETE,
            () => {
                console.log('Player load complete');
                const mediaInformation = playerManager.getMediaInformation();
                if (mediaInformation && mediaInformation.contentType) {
                    if (mediaInformation.contentType.startsWith('audio/')) {
                        showAudioOverlay(mediaInformation);
                    }
                }
            }
        );

        playerManager.addEventListener(
            cast.framework.events.EventType.MEDIA_FINISHED,
            () => {
                console.log('Media finished');
                // Check if there's a queue with more items
                const queueItems = playerManager.getQueueItems();
                if (!queueItems || queueItems.length === 0) {
                    hideAudioOverlay();
                }
            }
        );

    } catch (e) {
        console.error('Init error:', e);
        statusEl.textContent = 'Error: ' + e.message;
    }

    // Function to show audio overlay with media info
    function showAudioOverlay(media) {
        audioOverlay.classList.add('active');

        // Update title if available
        const titleElement = audioOverlay.querySelector('.audio-title');
        const infoElement = audioOverlay.querySelector('.audio-info');

        if (media.metadata && media.metadata.title) {
            titleElement.textContent = media.metadata.title;
            infoElement.textContent = 'Now Playing';
        } else {
            titleElement.textContent = 'Audio Streaming';
            infoElement.textContent = 'Now playing audio content';
        }
    }

    // Function to hide audio overlay
    function hideAudioOverlay() {
        audioOverlay.classList.remove('active');
    }

    // --- IMAGE DISPLAY FUNCTIONS ---

    // Function to show image from custom message
    function showImageFromCustomMessage(data) {
        console.log('ðŸ“· showImageFromCustomMessage called');
        console.log('   URL:', data.url);
        console.log('   Title:', data.title);
        console.log('   ContentType:', data.contentType);

        const imageDisplay = document.getElementById('imageDisplay');
        const remoteVideo = document.getElementById('remoteVideo');
        const youtubePlayerEl = document.getElementById('youtubePlayer');
        const audioOverlay = document.getElementById('audio-overlay');
        const statusEl = document.getElementById('status');

        if (!data.url) {
            console.error('âŒ No URL in SHOW_IMAGE message');
            return;
        }

        // Hide other elements
        remoteVideo.style.display = 'none';
        youtubePlayerEl.style.display = 'none';
        audioOverlay.classList.remove('active');
        statusEl.style.display = 'none'; // Hide status when showing image

        // Show and load image
        imageDisplay.style.display = 'block';
        imageDisplay.src = data.url;

        imageDisplay.onload = function() {
            console.log('âœ… Image loaded successfully from:', data.url);
        };

        imageDisplay.onerror = function(error) {
            console.error('âŒ Failed to load image:', error);
            console.error('   URL was:', data.url);
            console.error('   Check if URL is accessible from TV network');
            console.error('   Check if HTTP server is running on Android device');
            // Show status with error message
            statusEl.style.display = 'block';
            statusEl.textContent = 'Failed to load image';
        };

        console.log('ðŸ“· Image element updated, src set to:', data.url);
    }

    // Function to hide image and restore other elements
    function hideImage() {
        console.log('ðŸ“· hideImage called');
        const imageDisplay = document.getElementById('imageDisplay');
        const remoteVideo = document.getElementById('remoteVideo');
        const statusEl = document.getElementById('status');

        imageDisplay.style.display = 'none';
        imageDisplay.src = '';

        // Restore video and status if needed
        remoteVideo.style.display = 'block';
        statusEl.style.display = 'block';
    }

    // --- YOUTUBE FUNCTIONS WITH ENHANCED LOGGING ---
    // Make youtubePlayer global so handleYouTubeCommand can access it
    var youtubePlayer = null;
    var isYouTubeApiReady = false;
    var isYouTubeApiLoading = false;
    var pendingVideoId = null;

    function loadYouTubeVideo(videoId) {
        console.log(`[DEBUG] 1. loadYouTubeVideo called with ID: ${videoId}`);
        pendingVideoId = videoId;

        // Hide image when starting YouTube playback
        hideImage();

        statusEl.style.display = 'none';
        remoteVideo.style.display = 'none';
        youtubePlayerEl.style.display = 'block';
        console.log('[DEBUG] 2. Player container is now visible (black screen is expected here).');
        if (isYouTubeApiReady && youtubePlayer) {
            console.log('[DEBUG] 3a. API is ready. Playing pending video now.');
            playPendingVideo();
        } else if (!isYouTubeApiLoading) {
            console.log('[DEBUG] 3b. API not ready. Injecting API script from youtube.com.');
            isYouTubeApiLoading = true;
            const tag = document.createElement('script');
            tag.src = "https://www.youtube.com/iframe_api";
            tag.onerror = function() {
                console.error('[FATAL] FAILED TO LOAD THE YOUTUBE IFRAME API SCRIPT. Check network or server security policies.');
            };
            const firstScriptTag = document.getElementsByTagName('script')[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        } else {
            console.log('[DEBUG] 3c. API is currently loading. Waiting for it to complete.');
        }
    }

    window.onYouTubeIframeAPIReady = function() {
        console.log('[DEBUG] 4. onYouTubeIframeAPIReady has been called by the YouTube script.');
        isYouTubeApiReady = true;
        isYouTubeApiLoading = false;
        if (!youtubePlayer) {
            console.log('[DEBUG] 5. Creating new YT.Player object.');
            try {
                youtubePlayer = new YT.Player('youtubePlayer', {
                    height: '100%',
                    width: '100%',
                    videoId: pendingVideoId,
                    playerVars: { 'autoplay': 1, 'controls': 1 },
                    events: {
                        'onReady': onPlayerReady,
                        'onError': onPlayerError,
                        'onStateChange': onPlayerStateChange
                    }
                });
            } catch (e) {
                 console.error('[FATAL] Error creating YT.Player. Is YT defined?', e);
            }
        }
    }

    function onPlayerReady(event) {
        console.log('[DEBUG] 6. YouTube Player is ready and firing onReady event.');
        playPendingVideo();
    }

    function onPlayerError(event) {
        console.error('[FATAL] YouTube Player Error:', event.data);
    }

    var lastSeekTime = 0;
    var isCurrentlySeeking = false;
    var isTVShowingAd = false;

    // Check if TV is showing ad
    function checkTVAd() {
        try {
            if (!youtubePlayer) return false;

            // Method 1: Check player container for ad class
            var playerContainer = document.querySelector('.html5-video-player');
            if (playerContainer && playerContainer.classList.contains('ad-showing')) {
                return true;
            }

            // Method 2: Check for ad badge/overlay
            var adBadge = document.querySelector('.ytp-ad-text, .ytp-ad-preview-text, .ytp-ad-message-container');
            if (adBadge && adBadge.offsetParent !== null) {
                return true;
            }

            // Method 3: Check for skip button
            var skipButton = document.querySelector('.ytp-ad-skip-button, .ytp-ad-skip-button-modern');
            if (skipButton && skipButton.offsetParent !== null) {
                return true;
            }

            // Method 4: Check ad info panel
            var adInfo = document.querySelector('.ytp-ad-info-dialog-container');
            if (adInfo && adInfo.offsetParent !== null) {
                return true;
            }

            return false;
        } catch(e) {
            console.error('Error checking TV ad state:', e);
            return false;
        }
    }

    // Monitor ad state periodically
    setInterval(function() {
        var isShowingAd = checkTVAd();

        if (isShowingAd && !isTVShowingAd) {
            console.log('[YT_AD] ðŸš« Ad started on TV');
            isTVShowingAd = true;
            sendEventToPhone('YT_AD_STARTED', {});
        } else if (!isShowingAd && isTVShowingAd) {
            console.log('[YT_AD] âœ… Ad ended on TV');
            isTVShowingAd = false;
            sendEventToPhone('YT_AD_ENDED', {});
        }
    }, 500);

    function onPlayerStateChange(event) {
        console.log('[YT_EVENT] Player state changed:', event.data);

        const currentTime = youtubePlayer ? youtubePlayer.getCurrentTime() : 0;

        // Detect seeking (big jump in time during buffering)
        if (Math.abs(currentTime - lastSeekTime) > 2 && event.data === 3) {
            if (!isCurrentlySeeking) {
                isCurrentlySeeking = true;
                sendEventToPhone('YT_SEEK_START', {
                    currentTime: currentTime
                });
            }
        }

        // Seek complete (buffering -> playing/paused)
        if (isCurrentlySeeking && (event.data === 1 || event.data === 2)) {
            isCurrentlySeeking = false;
            sendEventToPhone('YT_SEEK_COMPLETE', {
                currentTime: currentTime
            });
        }

        lastSeekTime = currentTime;

        // Send state change to phone
        sendEventToPhone('YT_STATE_CHANGE', {
            state: event.data, // -1: unstarted, 0: ended, 1: playing, 2: paused, 3: buffering, 5: cued
            currentTime: currentTime,
            duration: youtubePlayer ? youtubePlayer.getDuration() : 0,
            volume: youtubePlayer ? youtubePlayer.getVolume() : 0
        });
    }

    function sendEventToPhone(type, data) {
        try {
            const castContext = cast.framework.CastReceiverContext.getInstance();
            const message = {
                type: type,
                ...data
            };

            // Send to all connected senders
            castContext.sendCustomMessage('urn:x-cast:com.xxx.screenmirroring', undefined, message);
            console.log('[YT_EVENT] Event sent to phone:', message);
        } catch (e) {
            console.error('[YT_EVENT] Error sending event:', e);
        }
    }

    function playPendingVideo() {
        if (youtubePlayer && pendingVideoId) {
            console.log(`[DEBUG] 7. Calling loadVideoById with '${pendingVideoId}'.`);
            youtubePlayer.loadVideoById(pendingVideoId);
            pendingVideoId = null;
        } else {
             console.warn('[DEBUG] playPendingVideo called, but player or pendingVideoId is missing.');
        }
    }
    /**
     * A helper function to clean up the YouTube player state.
     */
    function cleanupYouTube() {
        if (youtubePlayer) {
            youtubePlayer.stopVideo();
        }
        youtubePlayerEl.style.display = 'none';
        // Show other elements if needed
        statusEl.style.display = 'block';
        remoteVideo.style.display = 'block';
    }

    /**
     * A helper function to clean up the WebRTC state.
     */
    function cleanupWebRTC() {
        if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
        }
        remoteVideo.srcObject = null;
    }

    // --- YOUTUBE CONTROL FUNCTIONS ---

    /**
     * Handle YouTube control commands (play, pause, seek, volume, etc.)
     * This replaces the need for youtube-controls.js
     */
    function handleYouTubeCommand(data) {
        console.log('[YT_CONTROL] handleYouTubeCommand called');
        console.log('[YT_CONTROL] data:', data);
        console.log('[YT_CONTROL] typeof youtubePlayer:', typeof youtubePlayer);
        console.log('[YT_CONTROL] youtubePlayer value:', youtubePlayer);
        console.log('[YT_CONTROL] window.youtubePlayer:', window.youtubePlayer);

        // Check if YouTube player is available
        if (typeof youtubePlayer === 'undefined' || !youtubePlayer) {
            console.warn('[YT_CONTROL] YouTube player not ready yet');
            console.warn('[YT_CONTROL] youtubePlayer is:', youtubePlayer);
            return;
        }

        const command = data.command;
        console.log('[YT_CONTROL] Handling command:', command);
        console.log('[YT_CONTROL] Player state before command:', youtubePlayer.getPlayerState ? youtubePlayer.getPlayerState() : 'N/A');

        try {
            switch (command) {
                case 'play':
                    console.log('[YT_CONTROL] Playing video');
                    youtubePlayer.playVideo();
                    console.log('[YT_CONTROL] playVideo() called');
                    break;

                case 'pause':
                    console.log('[YT_CONTROL] Pausing video');
                    youtubePlayer.pauseVideo();
                    console.log('[YT_CONTROL] pauseVideo() called');
                    break;

                case 'stop':
                    console.log('[YT_CONTROL] Stopping video');
                    youtubePlayer.stopVideo();
                    console.log('[YT_CONTROL] stopVideo() called');
                    break;

                case 'seek':
                    if (data.relative) {
                        const currentTime = youtubePlayer.getCurrentTime();
                        const newTime = currentTime + data.seconds;
                        console.log('[YT_CONTROL] Seeking relative:', data.seconds, 'seconds');
                        youtubePlayer.seekTo(newTime, true);
                    } else {
                        const duration = youtubePlayer.getDuration();
                        const seekTime = (duration * data.progress) / 100;
                        console.log('[YT_CONTROL] Seeking to progress:', data.progress, '%');
                        youtubePlayer.seekTo(seekTime, true);
                    }
                    break;

                case 'volume':
                    const level = data.level || 100;
                    console.log('[YT_CONTROL] Setting volume to:', level);
                    youtubePlayer.setVolume(level);
                    if (level === 0) {
                        youtubePlayer.mute();
                    } else {
                        youtubePlayer.unMute();
                    }
                    break;

                default:
                    console.warn('[YT_CONTROL] Unknown command:', command);
            }

            // Log player state after command
            console.log('[YT_CONTROL] Command executed successfully');
            setTimeout(() => {
                console.log('[YT_CONTROL] Player state after command:', youtubePlayer.getPlayerState ? youtubePlayer.getPlayerState() : 'N/A');
            }, 100);
        } catch (e) {
            console.error('[YT_CONTROL] Error executing command:', command, e);
            console.error('[YT_CONTROL] Error stack:', e.stack);
        }
    }

    // --- AUDIO FUNCTIONS ---
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)({
                sampleRate: 48000,
                latencyHint: 'interactive'
            });
            console.log('âœ“ AudioContext initialized:', audioContext.sampleRate, 'Hz');
        } catch (e) {
            console.error('Failed to initialize AudioContext:', e);
        }
    

    function handleAudioData(data) {
        if (!audioContext) {
            console.warn('AudioContext not initialized, initializing now...');
            initializeAudioContext();
            if (!audioContext) {
                console.error('Failed to initialize AudioContext');
                return;
            }
        }

        try {
            // Decode base64 audio data
            const binaryString = atob(data.data);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }

            // Convert PCM bytes to Float32Array
            const int16Array = new Int16Array(bytes.buffer);
            const float32Array = new Float32Array(int16Array.length);
            for (let i = 0; i < int16Array.length; i++) {
                float32Array[i] = int16Array[i] / 32768.0; // Convert to -1.0 to 1.0 range
            }

            // Split stereo data into left and right channels
            const channels = data.channels || 2;
            const samplesPerChannel = float32Array.length / channels;

            // Create AudioBuffer
            const audioBuffer = audioContext.createBuffer(channels, samplesPerChannel, data.sampleRate || 48000);

            if (channels === 2) {
                const leftChannel = audioBuffer.getChannelData(0);
                const rightChannel = audioBuffer.getChannelData(1);
                for (let i = 0; i < samplesPerChannel; i++) {
                    leftChannel[i] = float32Array[i * 2];
                    rightChannel[i] = float32Array[i * 2 + 1];
                }
            } else {
                const channelData = audioBuffer.getChannelData(0);
                for (let i = 0; i < samplesPerChannel; i++) {
                    channelData[i] = float32Array[i];
                }
            }

            playAudioBuffer(audioBuffer);

            // Log occasionally to confirm audio is being received
            if (!window.audioPacketCount) window.audioPacketCount = 0;
            window.audioPacketCount++;
            if (window.audioPacketCount % 100 === 0) {
                console.log('âœ“ System audio packets received:', window.audioPacketCount);
            }
        } catch (e) {
            console.error('Error processing audio data:', e);
        }
    }

    function playAudioBuffer(audioBuffer) {
        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(audioContext.destination);

        // Schedule playback
        const currentTime = audioContext.currentTime;
        if (nextPlayTime < currentTime) {
            nextPlayTime = currentTime;
        }

        source.start(nextPlayTime);
        nextPlayTime += audioBuffer.duration;
    }

    function stopAudioPlayback() {
        audioQueue = [];
        isPlayingAudio = false;
        nextPlayTime = 0;
        if (audioContext) {
            try {
                audioContext.close();
                audioContext = null;
            } catch (e) {
                console.error('Error closing AudioContext:', e);
            }
        }
    }

    async function handleOffer(data) {
        try {
            console.log('Handling offer');

            // Hide image when starting WebRTC screen mirroring
            hideImage();

            const configuration = {
                iceServers: [{
                    urls: 'stun:stun.l.google.com:19302'
                }],
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require'
            };
            peerConnection = new RTCPeerConnection(configuration);

            let streamSet = false;

            peerConnection.ontrack = (event) => {
                console.log('Track received:', event.track.kind, 'enabled:', event.track.enabled, 'muted:', event.track.muted);

                if (event.streams && event.streams[0]) {
                    if (!streamSet) {
                        console.log('Setting video stream with', event.streams[0].getTracks().length, 'tracks');

                        // Log all tracks
                        event.streams[0].getTracks().forEach(track => {
                            console.log('Stream track:', track.kind, 'id:', track.id, 'enabled:', track.enabled, 'readyState:', track.readyState);
                        });

                        remoteVideo.srcObject = event.streams[0];
                        streamSet = true;

                        // Ensure video is not muted and has volume
                        remoteVideo.muted = false;
                        remoteVideo.volume = 1.0;

                        remoteVideo.play().then(() => {
                            console.log('âœ“ Video playback started');
                            console.log('Video element - muted:', remoteVideo.muted, 'volume:', remoteVideo.volume);

                            // Check audio tracks
                            const audioTracks = event.streams[0].getAudioTracks();
                            console.log('Audio tracks:', audioTracks.length);
                            audioTracks.forEach((track, idx) => {
                                console.log(`Audio track ${idx}:`, {
                                    id: track.id,
                                    label: track.label,
                                    enabled: track.enabled,
                                    muted: track.muted,
                                    readyState: track.readyState
                                });
                            });

                            statusEl.textContent = 'Streaming (Video + Audio)';
                        }).catch(e => console.error('Play failed:', e));
                    }
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                console.log('ICE state:', peerConnection.iceConnectionState);
                if (peerConnection.iceConnectionState === 'connected') {
                    statusEl.textContent = 'Streaming (Video + Audio)';
                }
            };

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    sendMessage({
                        type: 'ice_candidate',
                        candidate: event.candidate.candidate,
                        sdpMid: event.candidate.sdpMid,
                        sdpMLineIndex: event.candidate.sdpMLineIndex
                    });
                }
            };

            await peerConnection.setRemoteDescription(new RTCSessionDescription({
                type: 'offer',
                sdp: data.sdp
            }));
            console.log('Remote description set');

            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            console.log('Answer created');

            sendMessage({
                type: 'answer',
                sdp: answer.sdp
            });

            setTimeout(() => {
                const receivers = peerConnection.getReceivers();
                console.log('Total receivers:', receivers.length);
                receivers.forEach((receiver, index) => {
                    if (receiver.track) {
                        console.log(`Receiver ${index}:`, receiver.track.kind, 'state:', receiver.track.readyState, 'enabled:', receiver.track.enabled);
                    }
                });
            }, 1500);

        } catch (e) {
            console.error('Offer handling error:', e);
            statusEl.textContent = 'Error: ' + e.message;
        }
    }

    async function handleIceCandidate(data) {
        try {
            if (peerConnection && data.candidate) {
                await peerConnection.addIceCandidate(new RTCIceCandidate({
                    candidate: data.candidate,
                    sdpMid: data.sdpMid,
                    sdpMLineIndex: data.sdpMLineIndex
                }));
            }
        } catch (e) {
            console.error('ICE candidate error:', e);
        }
    }

    function sendMessage(messageObject) {
        try {
            const messageStr = JSON.stringify(messageObject);
            context.sendCustomMessage(NAMESPACE, undefined, messageStr);
        } catch (e) {
            console.error('Send message error:', e);
        }
    }
</script>
</body>
</html>
