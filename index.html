<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebRTC Screen Mirroring</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #remoteVideo {
            width: 100vw;
            height: 100vh;
            object-fit: contain;
            background: #000;
        }
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.2em;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="status">Loading Cast SDK...</div>
    <video id="remoteVideo" autoplay playsinline></video>

    <script src="https://www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
    <script>
        // The Cast SDK will automatically call this function when the 'cast' API is ready.
        // This prevents all race conditions with the SDK loading.
        window.__onGCastApiAvailable = function(isAvailable) {
            if (isAvailable) {
                initializeApp();
            } else {
                document.getElementById('status').textContent = 'FATAL: Cast API not available.';
            }
        };

        function initializeApp() {
            const statusEl = document.getElementById('status');
            const remoteVideo = document.getElementById('remoteVideo');
            const NAMESPACE = 'urn:x-cast:com.xxx.screenmirroring';
            
            const context = cast.framework.CastReceiverContext.getInstance();
            const castReceiverOptions = new cast.framework.CastReceiverOptions();
            castReceiverOptions.disableIdleTimeout = true;
            let peerConnection = null;

            context.addCustomMessageListener(NAMESPACE, (customEvent) => {
                try {
                    let data = customEvent.data;
                    if (typeof data === 'string') data = JSON.parse(data);
                    
                    if (data.type === 'offer') {
                        handleOffer(data);
                    } else if (data.type === 'ice_candidate') {
                        handleIceCandidate(data);
                    }
                } catch (e) {
                    console.error('Message processing error:', e);
                }
            });

            context.addEventListener(cast.framework.system.EventType.SENDER_DISCONNECTED, () => {
                statusEl.textContent = 'Disconnected';
                if (peerConnection) peerConnection.close();
                remoteVideo.srcObject = null;
            });

            context.start(castReceiverOptions);
            statusEl.textContent = 'Ready for Connection...';

            async function handleOffer(data) {
                try {
                    console.log('Handling offer...');
                    peerConnection = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });

                    // THIS IS THE ONLY PLACE THE STREAM SHOULD BE HANDLED.
                    peerConnection.ontrack = (event) => {
                        console.log('âœ“ Track received:', event.track.kind);
                        if (event.streams && event.streams[0]) {
                            // Only set the srcObject once.
                            if (remoteVideo.srcObject !== event.streams[0]) {
                                remoteVideo.srcObject = event.streams[0];
                                console.log('Stream attached to video element.');
                            }
                        }
                    };

                    peerConnection.oniceconnectionstatechange = () => {
                        console.log('ICE state:', peerConnection.iceConnectionState);
                        if (peerConnection.iceConnectionState === 'connected') {
                            statusEl.textContent = 'Streaming';
                        }
                    };

                    peerConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            sendMessage({
                                type: 'ice_candidate',
                                candidate: event.candidate.candidate,
                                sdpMid: event.candidate.sdpMid,
                                sdpMLineIndex: event.candidate.sdpMLineIndex
                            });
                        }
                    };
                    
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    sendMessage({ type: 'answer', sdp: answer.sdp });

                } catch (e) {
                    console.error('Offer handling error:', e);
                    statusEl.textContent = 'Error: ' + e.message;
                }
            }

            async function handleIceCandidate(data) {
                try {
                    if (peerConnection && data.candidate) {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(data));
                    }
                } catch (e) {
                    console.error('ICE candidate error:', e);
                }
            }

            function sendMessage(messageObject) {
                try {
                    context.sendCustomMessage(NAMESPACE, undefined, JSON.stringify(messageObject));
                } catch (e) {
                    console.error('Send message error:', e);
                }
            }
        }

        // --- THE "PLAY THEN UNMUTE" STRATEGY ---
        // This is the most reliable way to handle browser autoplay policies.
        document.getElementById('remoteVideo').addEventListener('playing', () => {
            console.log('Video is now playing!');
            const videoElement = document.getElementById('remoteVideo');
            // Once playback has officially started, we can safely unmute.
            videoElement.muted = false;
            videoElement.volume = 1.0;
            console.log('Attempted to unmute. Muted:', videoElement.muted, 'Volume:', videoElement.volume);

            if (videoElement.srcObject) {
                videoElement.srcObject.getAudioTracks().forEach(track => {
                    track.enabled = true; // Ensure the track itself is enabled
                    console.log('Audio track confirmed enabled on playing:', track.id);
                });
            }
        });

    </script>
</body>
</html>
