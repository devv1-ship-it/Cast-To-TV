<!--THIS FILE IS FOR NATIVE SCREEN MIRRORING using Broadway.js H.264 decoder-->
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Native Screen Mirroring</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            color: white;
            font-family: Arial, sans-serif;
        }
        #videoCanvas {
            width: 100vw;
            height: 100vh;
            object-fit: contain;
            background: #000;
        }
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.2em;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 100;
        }
        #debug {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 0.9em;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 100;
            max-width: 400px;
        }
    </style>
</head>
<body>
<div id="status">Loading decoder...</div>
<div id="debug"></div>
<canvas id="videoCanvas"></canvas>

<script src="https://www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
<script src="https://cdn.jsdelivr.net/npm/broadway-player@1.0.5/Player/Player.min.js"></script>

<script>
    const statusEl = document.getElementById('status');
    const debugEl = document.getElementById('debug');
    const canvas = document.getElementById('videoCanvas');
    const NAMESPACE = 'urn:x-cast:com.xxx.screenmirroring.native';

    let context = null;
    let player = null;
    let frameCount = 0;
    let lastFrameTime = Date.now();

    function updateDebug(msg) {
        debugEl.innerHTML = msg;
    }

    function log(msg) {
        console.log(msg);
        updateDebug(msg);
    }

    // Initialize Broadway H.264 decoder
    function initializeDecoder() {
        try {
            player = new Player({
                useWorker: true,
                workerFile: "https://cdn.jsdelivr.net/npm/broadway-player@1.0.5/Player/Decoder.min.js",
                webgl: true,
                size: { width: 720, height: 1640 }
            });

            player.canvas = canvas;

            statusEl.textContent = 'Decoder ready';
            console.log('Broadway decoder initialized');

        } catch (e) {
            console.error('Failed to initialize decoder:', e);
            statusEl.textContent = 'Error: Decoder failed';
            log('Decoder error: ' + e.message);
        }
    }

    try {
        context = cast.framework.CastReceiverContext.getInstance();
        const castReceiverOptions = new cast.framework.CastReceiverOptions();
        castReceiverOptions.disableIdleTimeout = true;
        castReceiverOptions.maxInactivity = 3600;

        context.addCustomMessageListener(NAMESPACE, function(customEvent) {
            try {
                let data = customEvent.data;
                if (typeof data === 'string') {
                    data = JSON.parse(data);
                }

                if (data.type === 'video_format') {
                    handleVideoFormat(data);
                } else if (data.type === 'video_data') {
                    handleVideoData(data);
                }
            } catch (e) {
                console.error('Message processing error:', e);
                log('Error: ' + e.message);
            }
        });

        context.addEventListener(cast.framework.system.EventType.READY, () => {
            statusEl.textContent = 'Ready';
            console.log('Receiver ready');
            initializeDecoder();
            sendReadyMessage();
        });

        context.addEventListener(cast.framework.system.EventType.SENDER_CONNECTED, (event) => {
            statusEl.textContent = 'Connected - Initializing...';
            console.log('Sender connected:', event.senderId);
            if (!player) {
                initializeDecoder();
            }
            sendReadyMessage();
        });

        context.addEventListener(cast.framework.system.EventType.SENDER_DISCONNECTED, () => {
            statusEl.textContent = 'Disconnected';
            frameCount = 0;
        });

        context.start(castReceiverOptions);

    } catch (e) {
        console.error('Init error:', e);
        statusEl.textContent = 'Error: ' + e.message;
    }

    function sendReadyMessage() {
        try {
            const message = JSON.stringify({ type: 'ready' });
            context.sendCustomMessage(NAMESPACE, undefined, message);
            console.log('Sent ready message');
        } catch (e) {
            console.error('Failed to send ready message:', e);
        }
    }

    function handleVideoFormat(data) {
        console.log('Video format received:', data);

        // Resize canvas
        canvas.width = data.width;
        canvas.height = data.height;

        log(`Video: ${data.width}x${data.height} @ ${data.fps}fps<br>Codec: ${data.codec}`);
        statusEl.textContent = 'Ready to receive video';
    }

    function handleVideoData(data) {
        try {
            if (!player) {
                console.warn('Decoder not ready');
                return;
            }

            frameCount++;

            // Decode base64 H.264 data
            const binaryString = atob(data.data);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }

            // Check if this is a keyframe
            const isKeyFrame = (data.flags & 1) !== 0;

            // Decode and render frame
            player.decode(bytes);

            // Update stats
            const now = Date.now();
            const fps = 1000 / (now - lastFrameTime);
            lastFrameTime = now;

            if (frameCount % 30 === 0) {
                statusEl.textContent = `Streaming (${frameCount} frames, ${fps.toFixed(1)} fps)`;
                log(`Frames: ${frameCount}<br>FPS: ${fps.toFixed(1)}<br>Keyframe: ${isKeyFrame}`);
            }

            if (frameCount === 1) {
                console.log('First frame decoded!');
                statusEl.textContent = 'Streaming';
            }

        } catch (e) {
            console.error('Error processing video data:', e);
            if (frameCount < 10) {
                log('Video decode error: ' + e.message);
            }
        }
    }

</script>
</body>
</html>

