<!--THIS FILE IS UPLOADED TO SERVER AND PUBLISHED-->
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebRTC Screen Mirroring</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            color: white;
            font-family: Arial, sans-serif;
        }
        #remoteVideo {
            width: 100vw;
            height: 100vh;
            object-fit: contain;
            background: #000;
        }
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.2em;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 100;
        }
    </style>
</head>
<body>
<div id="status">Connecting...</div>
<video id="remoteVideo" autoplay playsinline muted="false"></video>

<script src="https://www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
<script>
    const statusEl = document.getElementById('status');
    const remoteVideo = document.getElementById('remoteVideo');
    const NAMESPACE = 'urn:x-cast:com.xxx.screenmirroring';
    let peerConnection = null;
    const context = cast.framework.CastReceiverContext.getInstance();

    remoteVideo.muted = false;
    remoteVideo.volume = 1.0;

    // --- JITTER BUFFER & AUDIO PLAYBACK ENGINE (UNCHANGED) ---
    let audioContext = null;
    const audioQueue = [];
    let isPlayingAudio = false;
    let nextPlayTime = 0;

    function initializeAudioContext(sampleRate) {
        if (audioContext && audioContext.sampleRate === sampleRate) return;
        if (audioContext) audioContext.close();
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)({
                sampleRate: sampleRate, latencyHint: 'interactive'
            });
        } catch (e) { console.error('Failed to initialize AudioContext:', e); }
    }

    function processAudioQueue() {
        if (audioQueue.length === 0) { isPlayingAudio = false; return; }
        const bufferToPlay = audioQueue.shift();
        const source = audioContext.createBufferSource();
        source.buffer = bufferToPlay;
        source.connect(audioContext.destination);
        source.onended = processAudioQueue;
        const currentTime = audioContext.currentTime;
        if (nextPlayTime < currentTime) nextPlayTime = currentTime;
        source.start(nextPlayTime);
        nextPlayTime += bufferToPlay.duration;
    }
    
    // --- MAIN RECEIVER LOGIC ---
    const castReceiverOptions = new cast.framework.CastReceiverOptions();
    castReceiverOptions.disableIdleTimeout = true;
    context.addCustomMessageListener(NAMESPACE, function(customEvent) {
        // This only handles the initial connection now
        try {
            const data = JSON.parse(customEvent.data);
            if (data.type === 'offer') handleOffer(data);
            else if (data.type === 'ice_candidate') handleIceCandidate(data);
        } catch (e) {}
    });
    context.start(castReceiverOptions);

    async function handleOffer(data) {
        peerConnection = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });

        // ===================================================================
        // THIS IS THE KEY CHANGE: LISTEN FOR THE DATACHANNEL
        // ===================================================================
        peerConnection.ondatachannel = (event) => {
            const receiveChannel = event.channel;
            console.log('>>> Audio DataChannel received:', receiveChannel.label);
            
            // When a message (raw audio data) arrives, process it.
            receiveChannel.onmessage = async (messageEvent) => {
                // messageEvent.data is a raw ArrayBuffer, which is very fast.
                // We decode it and feed it into our jitter buffer.
                if (!audioContext) initializeAudioContext(24000);
                if (!audioContext) return;

                try {
                    const arrayBuffer = messageEvent.data;
                    const int16Array = new Int16Array(arrayBuffer);
                    const float32Array = new Float32Array(int16Array.length);
                    for (let i = 0; i < int16Array.length; i++) {
                        float32Array[i] = int16Array[i] / 32768.0;
                    }

                    const audioBuffer = audioContext.createBuffer(1, float32Array.length, audioContext.sampleRate);
                    audioBuffer.getChannelData(0).set(float32Array);
                    
                    audioQueue.push(audioBuffer);

                    const START_THRESHOLD = 5;
                    if (!isPlayingAudio && audioQueue.length > START_THRESHOLD) {
                        isPlayingAudio = true;
                        processAudioQueue();
                    }
                } catch(e) {}
            };
        };
        // ===================================================================

        // Video track logic is unchanged
        peerConnection.ontrack = (event) => {
            if (event.track.kind === 'video' && event.streams && event.streams[0]) {
                remoteVideo.srcObject = event.streams[0];
                remoteVideo.play().catch(e => console.error("Video play failed", e));
            }
        };

        // ICE candidate and SDP logic is unchanged
        peerConnection.onicecandidate = (event) => {
            if (event.candidate) sendMessage({ type: 'ice_candidate', ...event.candidate.toJSON() });
        };
        await peerConnection.setRemoteDescription(new RTCSessionDescription(data));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        sendMessage({ type: 'answer', sdp: answer.sdp });
    }

    async function handleIceCandidate(data) {
        if (peerConnection) await peerConnection.addIceCandidate(new RTCIceCandidate(data));
    }

    function sendMessage(messageObject) {
        context.sendCustomMessage(NAMESPACE, undefined, JSON.stringify(messageObject));
    }
</script>
</body>
</html>

