<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebRTC Screen Mirroring</title>
    <style>
        body { margin: 0; background-color: black; color: white; font-family: sans-serif; overflow: hidden; }
        #status {
            position: absolute; top: 20px; left: 20px; font-size: 1.5em;
            background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; z-index: 100;
        }
        #error-display {
            position: absolute; top: 80px; left: 20px; font-size: 1.2em; color: red;
            background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; z-index: 100;
        }
        video { width: 100vw; height: 100vh; object-fit: contain; }
    </style>
</head>
<body>
    <div id="status">Loading Cast SDK...</div>
    <div id="error-display"></div>
    <video id="remoteVideo" autoplay playsinline></video>

    <!-- Use the 'latest' SDK for best compatibility -->
    <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/latest/cast_receiver_framework.js"></script>
    
    <script>
        // The Cast SDK will automatically call this function when the 'cast' API is ready.
        window.__onGCastApiAvailable = function(isAvailable) {
            if (isAvailable) {
                initializeApp();
            } else {
                const statusEl = document.getElementById('status');
                const errorEl = document.getElementById('error-display');
                statusEl.textContent = 'FATAL ERROR';
                errorEl.textContent = 'Cast API failed to load. Please reboot Chromecast.';
            }
        };

        function initializeApp() {
            const statusEl = document.getElementById('status');
            const errorEl = document.getElementById('error-display');
            const remoteVideo = document.getElementById('remoteVideo');
            const NAMESPACE = 'urn:x-cast:com.xxx.screenmirroring';
            
            const context = cast.framework.CastReceiverContext.getInstance();
            const castReceiverOptions = new cast.framework.CastReceiverOptions();
            castReceiverOptions.disableIdleTimeout = true;
            let peerConnection = null;

            function updateStatus(message) {
                console.log(message);
                statusEl.textContent = message;
            }
            function displayError(step, error) {
                const errorMessage = `FAIL @ ${step}: ${error.message}`;
                console.error(errorMessage, error.stack);
                errorEl.textContent = errorMessage;
            }

            try {
                // THE FIX: Use the READY event listener instead of .then()
                context.addEventListener(cast.framework.system.EventType.READY, () => {
                    updateStatus('Ready for Connection...');
                });
                
                context.addEventListener(cast.framework.system.EventType.SENDER_DISCONNECTED, () => {
                    updateStatus('Sender Disconnected.');
                    if (peerConnection) peerConnection.close();
                });

                context.addCustomMessageListener(NAMESPACE, (customEvent) => {
                    try {
                        let data = customEvent.data;
                        if (typeof data === 'string') data = JSON.parse(data);
                        
                        if (data.type === 'offer') {
                            handleOffer(data);
                        } else if (data.type === 'ice_candidate') {
                            handleIceCandidate(data);
                        }
                    } catch (e) {
                        displayError('Processing Message', e);
                    }
                });

                // Start the context. The 'READY' event will fire when it's done.
                context.start(castReceiverOptions);
                updateStatus('Starting Cast Context...');

            } catch (e) {
                displayError('App Init', e);
            }

            async function handleOffer(data) {
                try {
                    updateStatus('Handling Offer...');
                    peerConnection = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });

                    peerConnection.ontrack = (event) => {
                        updateStatus('Track Received!');
                        if (event.streams && event.streams[0]) {
                            remoteVideo.srcObject = event.streams[0];
                            remoteVideo.play().catch(e => displayError('Video Play', e));
                        }
                    };

                    peerConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            sendMessage({
                                type: 'ice_candidate',
                                candidate: event.candidate.candidate,
                                sdpMid: event.candidate.sdpMid,
                                sdpMLineIndex: event.candidate.sdpMLineIndex
                            });
                        }
                    };
                    
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    sendMessage({ type: 'answer', sdp: answer.sdp });
                    updateStatus('Answer Sent. Waiting for video...');

                } catch (e) {
                    displayError('Handle Offer', e);
                }
            }

            async function handleIceCandidate(data) {
                try {
                    if (peerConnection && data.candidate) {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(data));
                    }
                } catch (e) {
                    displayError('Handle ICE', e);
                }
            }

            function sendMessage(messageObject) {
                try {
                    context.sendCustomMessage(NAMESPACE, undefined, JSON.stringify(messageObject));
                } catch (e) {
                    displayError('Send Message', e);
                }
            }
        }
    </script>
</body>
</html>
