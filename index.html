<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebRTC Screen Mirroring</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            color: white;
            font-family: Arial, sans-serif;
        }
        #remoteVideo {
            width: 100vw;
            height: 100vh;
            object-fit: contain;
            background: #000;
        }
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.2em;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 100;
        }
    </style>
</head>
<body>
<div id="status">Connecting...</div>
<video id="remoteVideo" autoplay playsinline></video>

<script src="https://www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
<script>
    const statusEl = document.getElementById('status');
    const remoteVideo = document.getElementById('remoteVideo');
    const NAMESPACE = 'urn:x-cast:com.xxx.screenmirroring';
    let peerConnection = null;
    let context = null;

    // Audio playback components
    let audioContext = null;
    let audioQueue = [];
    let isPlayingAudio = false;
    let nextPlayTime = 0;

    try {
        context = cast.framework.CastReceiverContext.getInstance();
        const castReceiverOptions = new cast.framework.CastReceiverOptions();
        castReceiverOptions.disableIdleTimeout = true;
        castReceiverOptions.maxInactivity = 3600;

        context.addCustomMessageListener(NAMESPACE, function(customEvent) {
            try {
                let data = customEvent.data;
                if (typeof data === 'string') {
                    data = JSON.parse(data);
                }

                if (data.type === 'offer') {
                    handleOffer(data);
                } else if (data.type === 'ice_candidate') {
                    handleIceCandidate(data);
                } else if (data.type === 'audio') {
                    handleAudioData(data);
                }
            } catch (e) {
                console.error('Message processing error:', e);
            }
        });

        context.addEventListener(cast.framework.system.EventType.READY, () => {
            statusEl.textContent = 'Ready';
            console.log('Receiver ready');
            initializeAudioContext();
        });

        context.addEventListener(cast.framework.system.EventType.SENDER_CONNECTED, (event) => {
            statusEl.textContent = 'Connected - Waiting for stream...';
            console.log('Sender connected:', event.senderId);
        });

        context.addEventListener(cast.framework.system.EventType.SENDER_DISCONNECTED, () => {
            statusEl.textContent = 'Disconnected';
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            remoteVideo.srcObject = null;
            stopAudioPlayback();
        });

        context.start(castReceiverOptions);

    } catch (e) {
        console.error('Init error:', e);
        statusEl.textContent = 'Error: ' + e.message;
    }

    function initializeAudioContext() {
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)({
                sampleRate: 48000,
                latencyHint: 'interactive'
            });
            console.log('‚úì AudioContext initialized:', audioContext.sampleRate, 'Hz');
        } catch (e) {
            console.error('Failed to initialize AudioContext:', e);
        }
    }

    function handleAudioData(data) {
        if (!audioContext) {
            console.warn('AudioContext not initialized');
            return;
        }

        try {
            // Decode base64 audio data
            const binaryString = atob(data.data);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }

            // Convert PCM bytes to Float32Array
            const int16Array = new Int16Array(bytes.buffer);
            const float32Array = new Float32Array(int16Array.length);
            for (let i = 0; i < int16Array.length; i++) {
                float32Array[i] = int16Array[i] / 32768.0; // Convert to -1.0 to 1.0 range
            }

            // Split stereo data into left and right channels
            const channels = data.channels || 2;
            const samplesPerChannel = float32Array.length / channels;

            // Create AudioBuffer
            const audioBuffer = audioContext.createBuffer(channels, samplesPerChannel, data.sampleRate || 48000);

            if (channels === 2) {
                const leftChannel = audioBuffer.getChannelData(0);
                const rightChannel = audioBuffer.getChannelData(1);
                for (let i = 0; i < samplesPerChannel; i++) {
                    leftChannel[i] = float32Array[i * 2];
                    rightChannel[i] = float32Array[i * 2 + 1];
                }
            } else {
                const channelData = audioBuffer.getChannelData(0);
                for (let i = 0; i < samplesPerChannel; i++) {
                    channelData[i] = float32Array[i];
                }
            }

            playAudioBuffer(audioBuffer);
        } catch (e) {
            console.error('Error processing audio data:', e);
        }
    }

    function playAudioBuffer(audioBuffer) {
        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(audioContext.destination);

        // Schedule playback
        const currentTime = audioContext.currentTime;
        if (nextPlayTime < currentTime) {
            nextPlayTime = currentTime;
        }

        source.start(nextPlayTime);
        nextPlayTime += audioBuffer.duration;
    }

    function stopAudioPlayback() {
        audioQueue = [];
        isPlayingAudio = false;
        nextPlayTime = 0;
        if (audioContext) {
            try {
                audioContext.close();
                audioContext = null;
            } catch (e) {
                console.error('Error closing AudioContext:', e);
            }
        }
    }

    async function handleOffer(data) {
        try {
            console.log('üì• Handling offer');

            const configuration = {
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require',
                sdpSemantics: 'unified-plan'
            };
            peerConnection = new RTCPeerConnection(configuration);

            let streamSet = false;
            let receivedStream = new MediaStream();

            peerConnection.ontrack = (event) => {
                console.log('üì∫ Track received:', event.track.kind, 'id:', event.track.id, 'enabled:', event.track.enabled, 'readyState:', event.track.readyState);

                // Add track to our stream
                receivedStream.addTrack(event.track);
                
                if (event.streams && event.streams[0]) {
                    if (!streamSet) {
                        console.log('‚úì Setting video stream from event.streams[0]');
                        remoteVideo.srcObject = event.streams[0];
                        streamSet = true;

                        remoteVideo.play().then(() => {
                            console.log('‚úì Video playback started');
                            statusEl.textContent = 'Streaming (Video + System Audio)';
                        }).catch(e => console.error('‚ùå Play failed:', e));
                    }
                } else if (!streamSet && receivedStream.getTracks().length > 0) {
                    // Fallback: use our manually constructed stream
                    console.log('‚úì Setting video stream from receivedStream, tracks:', receivedStream.getTracks().length);
                    remoteVideo.srcObject = receivedStream;
                    streamSet = true;
                    
                    remoteVideo.play().then(() => {
                        console.log('‚úì Video playback started (fallback method)');
                        statusEl.textContent = 'Streaming (Video + System Audio)';
                    }).catch(e => console.error('‚ùå Play failed:', e));
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                console.log('‚ö° ICE state:', peerConnection.iceConnectionState);
                if (peerConnection.iceConnectionState === 'connected') {
                    statusEl.textContent = 'Streaming (Video + System Audio)';
                    console.log('‚úì ICE Connected');
                } else if (peerConnection.iceConnectionState === 'failed') {
                    console.error('‚ùå ICE Connection Failed');
                    statusEl.textContent = 'Connection Failed';
                } else if (peerConnection.iceConnectionState === 'disconnected') {
                    console.warn('‚ö† ICE Disconnected');
                }
            };

            peerConnection.onconnectionstatechange = () => {
                console.log('üîó Connection state:', peerConnection.connectionState);
            };

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('üßä ICE candidate:', event.candidate.candidate);
                    sendMessage({
                        type: 'ice_candidate',
                        candidate: event.candidate.candidate,
                        sdpMid: event.candidate.sdpMid,
                        sdpMLineIndex: event.candidate.sdpMLineIndex
                    });
                } else {
                    console.log('‚úì ICE gathering complete');
                }
            };

            console.log('üìù Setting remote description...');
            await peerConnection.setRemoteDescription(new RTCSessionDescription({
                type: 'offer',
                sdp: data.sdp
            }));
            console.log('‚úì Remote description set');

            console.log('üìù Creating answer...');
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            console.log('‚úì Answer created and set as local description');

            console.log('üì§ Sending answer to sender');
            sendMessage({ type: 'answer', sdp: answer.sdp });

            // Debug: Check receivers after a delay
            setTimeout(() => {
                const receivers = peerConnection.getReceivers();
                console.log('üìä Receivers count:', receivers.length);
                receivers.forEach((receiver, index) => {
                    if (receiver.track) {
                        console.log(`  Track ${index}:`, receiver.track.kind, 'enabled:', receiver.track.enabled, 'state:', receiver.track.readyState, 'muted:', receiver.track.muted);
                    }
                });
                
                // Check video element
                console.log('üì∫ Video element srcObject:', remoteVideo.srcObject);
                if (remoteVideo.srcObject) {
                    const tracks = remoteVideo.srcObject.getTracks();
                    console.log('üì∫ Video element tracks:', tracks.length);
                    tracks.forEach((track, idx) => {
                        console.log(`  ${idx}: ${track.kind} - enabled: ${track.enabled}, readyState: ${track.readyState}`);
                    });
                }
            }, 2000);

        } catch (e) {
            console.error('‚ùå Offer handling error:', e);
            statusEl.textContent = 'Error: ' + e.message;
        }
    }

    async function handleIceCandidate(data) {
        try {
            if (peerConnection && data.candidate) {
                await peerConnection.addIceCandidate(new RTCIceCandidate({
                    candidate: data.candidate,
                    sdpMid: data.sdpMid,
                    sdpMLineIndex: data.sdpMLineIndex
                }));
            }
        } catch (e) {
            console.error('ICE candidate error:', e);
        }
    }

    function sendMessage(messageObject) {
        try {
            const messageStr = JSON.stringify(messageObject);
            context.sendCustomMessage(NAMESPACE, undefined, messageStr);
        } catch (e) {
            console.error('Send message error:', e);
        }
    }
</script>
</body>
</html>
