<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebRTC Screen Mirroring</title>
    <style>
        body { margin: 0; background-color: #000; color: white; font-family: Arial, sans-serif; }
        #remoteVideo { width: 100vw; height: 100vh; object-fit: contain; background: #000; }
        #status { position: absolute; top: 20px; left: 20px; font-size: 1.2em; background: rgba(0,0,0,0.7); padding: 10px 15px; border-radius: 5px; z-index: 100; }
    </style>
</head>
<body>
<div id="status">Connecting...</div>
<video id="remoteVideo" autoplay playsinline muted="false"></video>

<script src="https://www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
<script>
    const statusEl = document.getElementById('status');
    const remoteVideo = document.getElementById('remoteVideo');
    const NAMESPACE = 'urn:x-cast:com.xxx.screenmirroring';
    let peerConnection = null;
    let context = null;

    remoteVideo.muted = false;
    remoteVideo.volume = 1.0;

    // --- JITTER BUFFER FOR SMOOTH AUDIO ---
    let audioContext = null;
    const audioQueue = [];
    let isPlayingAudio = false;
    let nextPlayTime = 0;

    function initializeAudioContext(sampleRate) {
        if (audioContext && audioContext.sampleRate === sampleRate) return;
        if (audioContext) audioContext.close();
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)({
                sampleRate: sampleRate,
                latencyHint: 'interactive'
            });
            console.log('AudioContext initialized at:', audioContext.sampleRate, 'Hz');
        } catch (e) { console.error('Failed to initialize AudioContext:', e); }
    }

    function processAudioQueue() {
        if (audioQueue.length === 0) { isPlayingAudio = false; return; }
        const bufferToPlay = audioQueue.shift();
        const source = audioContext.createBufferSource();
        source.buffer = bufferToPlay;
        source.connect(audioContext.destination);
        source.onended = processAudioQueue;
        const currentTime = audioContext.currentTime;
        if (nextPlayTime < currentTime) nextPlayTime = currentTime;
        source.start(nextPlayTime);
        nextPlayTime += bufferToPlay.duration;
    }

    // This function is now called by the DataChannel's onmessage event.
    async function onAudioDataReceived(arrayBuffer) {
        if (!audioContext) initializeAudioContext(24000); // Default to our known sample rate
        if (!audioContext) return;

        try {
            const int16Array = new Int16Array(arrayBuffer);
            const float32Array = new Float32Array(int16Array.length);
            for (let i = 0; i < int16Array.length; i++) {
                float32Array[i] = int16Array[i] / 32768.0;
            }
            const audioBuffer = audioContext.createBuffer(1, float32Array.length, audioContext.sampleRate);
            audioBuffer.getChannelData(0).set(float32Array);
            audioQueue.push(audioBuffer);
            const START_THRESHOLD = 5;
            if (!isPlayingAudio && audioQueue.length > START_THRESHOLD) {
                isPlayingAudio = true;
                processAudioQueue();
            }
        } catch(e) {}
    }

    function stopAudioPlayback() {
        audioQueue.length = 0;
        isPlayingAudio = false;
        nextPlayTime = 0;
        if (audioContext) {
            try { audioContext.close(); audioContext = null; } catch (e) {}
        }
    }

    // --- YOUR CONNECTION LOGIC (UNCHANGED, BUT WITH DATACHANNEL ADDED) ---
    try {
        context = cast.framework.CastReceiverContext.getInstance();
        const castReceiverOptions = new cast.framework.CastReceiverOptions();
        castReceiverOptions.disableIdleTimeout = true;
        castReceiverOptions.maxInactivity = 3600;

        // The message listener is now only for signaling (offer/ice_candidate)
        context.addCustomMessageListener(NAMESPACE, function(customEvent) {
            try {
                let data = JSON.parse(customEvent.data);
                if (data.type === 'offer') {
                    handleOffer(data);
                } else if (data.type === 'ice_candidate') {
                    handleIceCandidate(data);
                }
            } catch (e) {}
        });

        context.addEventListener(cast.framework.system.EventType.READY, () => {
            statusEl.textContent = 'Ready';
        });
        context.addEventListener(cast.framework.system.EventType.SENDER_CONNECTED, (event) => {
            statusEl.textContent = 'Connected - Waiting for stream...';
        });
        context.addEventListener(cast.framework.system.EventType.SENDER_DISCONNECTED, () => {
            statusEl.textContent = 'Disconnected';
            if (peerConnection) peerConnection.close();
            remoteVideo.srcObject = null;
            stopAudioPlayback();
        });
        context.start(castReceiverOptions);
    } catch (e) {
        statusEl.textContent = 'Error: ' + e.message;
    }

    async function handleOffer(data) {
        try {
            console.log('Handling offer');
            const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }], bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require' };
            peerConnection = new RTCPeerConnection(configuration);

            // THE ONLY ADDITION: We tell the connection to listen for the DataChannel.
            peerConnection.ondatachannel = (event) => {
                const receiveChannel = event.channel;
                console.log('>>> Audio DataChannel received:', receiveChannel.label);
                // When a message (raw audio data) arrives, feed it to our jitter buffer.
                receiveChannel.onmessage = (messageEvent) => {
                    onAudioDataReceived(messageEvent.data);
                };
            };

            // Your ontrack logic is UNCHANGED.
            let streamSet = false;
            peerConnection.ontrack = (event) => {
                if (event.streams && event.streams[0] && !streamSet) {
                    remoteVideo.srcObject = event.streams[0];
                    streamSet = true;
                    remoteVideo.play().catch(e => console.error('Play failed:', e));
                }
            };

            // Your oniceconnectionstatechange logic is UNCHANGED.
            peerConnection.oniceconnectionstatechange = () => {
                if (peerConnection.iceConnectionState === 'connected') {
                    statusEl.textContent = 'Streaming (Video + Audio)';
                }
            };
            
            // Your onicecandidate logic is UNCHANGED.
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    sendMessage({ type: 'ice_candidate', candidate: event.candidate.candidate, sdpMid: event.candidate.sdpMid, sdpMLineIndex: event.candidate.sdpMLineIndex });
                }
            };

            // Your SDP negotiation logic is UNCHANGED.
            await peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp: data.sdp }));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            sendMessage({ type: 'answer', sdp: answer.sdp });

            // YOUR SETTIMEOUT IS UNCHANGED.
            setTimeout(() => {
                const receivers = peerConnection.getReceivers();
                console.log('Total receivers:', receivers.length);
                receivers.forEach((receiver) => {
                    if (receiver.track) {
                        console.log(`Receiver:`, receiver.track.kind, 'state:', receiver.track.readyState);
                    }
                });
            }, 1500);

        } catch (e) {
            console.error('Offer handling error:', e);
        }
    }

    async function handleIceCandidate(data) {
        try {
            if (peerConnection && data.candidate) {
                await peerConnection.addIceCandidate(new RTCIceCandidate({ candidate: data.candidate, sdpMid: data.sdpMid, sdpMLineIndex: data.sdpMLineIndex }));
            }
        } catch (e) {}
    }

    function sendMessage(messageObject) {
        try {
            const messageStr = JSON.stringify(messageObject);
            context.sendCustomMessage(NAMESPACE, undefined, messageStr);
        } catch (e) {}
    }
</script>
</body>
</html>
