<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Cast To TV - WebRTC Screen Mirroring</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
        }
        #video-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }
        #remoteVideo {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 1000;
        }
        #stats {
            position: absolute;
            top: 60px;
            left: 20px;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="status">Initializing WebRTC...</div>
    <div id="stats">Waiting for connection...</div>
    <div id="video-container">
        <video id="remoteVideo" autoplay playsinline muted></video>
    </div>

    <script src="https://www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
    <script>
        const context = cast.framework.CastReceiverContext.getInstance();
        const statusEl = document.getElementById('status');
        const statsEl = document.getElementById('stats');
        const remoteVideo = document.getElementById('remoteVideo');

        const NAMESPACE = 'urn:x-cast:com.xxx.screenmirroring';

        // WebRTC variables
        let peerConnection = null;
        let statsInterval = null;
        let lastBytesReceived = 0;
        let lastTimestamp = Date.now();

        console.log('=== WebRTC Cast Receiver Initializing ===');

        // Initialize Cast Receiver with optimizations
        const castReceiverOptions = new cast.framework.CastReceiverOptions();
        castReceiverOptions.disableIdleTimeout = true;
        castReceiverOptions.maxInactivity = 3600;

        // Handle WebRTC signaling messages
        context.addCustomMessageListener(NAMESPACE, function(customEvent) {
            try {
                const data = customEvent.data;
                console.log('Received message type:', data.type);

                if (data.type === 'offer') {
                    handleOffer(data);
                } else if (data.type === 'ice_candidate') {
                    handleIceCandidate(data);
                }
            } catch (error) {
                console.error('Error processing message:', error);
                statusEl.textContent = 'Error: ' + error.message;
            }
        });

        async function handleOffer(data) {
            try {
                statusEl.textContent = 'ðŸ“¡ Setting up WebRTC connection...';

                // Create peer connection with optimized settings
                const configuration = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' }
                    ],
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require',
                    // Optimize for low latency
                    iceTransportPolicy: 'all'
                };

                peerConnection = new RTCPeerConnection(configuration);

                // Handle incoming tracks (video + audio)
                peerConnection.ontrack = (event) => {
                    console.log('Received track:', event.track.kind, 'readyState:', event.track.readyState);
                    if (event.streams && event.streams[0]) {
                        remoteVideo.srcObject = event.streams[0];
                        
                        // Unmute video after receiving stream (muted initially to prevent echo)
                        remoteVideo.muted = false;
                        
                        // Force play
                        remoteVideo.play().then(() => {
                            console.log('Video playback started');
                            statusEl.textContent = 'âœ… Screen Mirroring Active (WebRTC)';
                            startStatsMonitoring();
                        }).catch(err => {
                            console.error('Error starting video playback:', err);
                        });
                    }
                };

                // Handle ICE connection state
                peerConnection.oniceconnectionstatechange = () => {
                    console.log('ICE Connection State:', peerConnection.iceConnectionState);
                    const state = peerConnection.iceConnectionState;
                    
                    if (state === 'connected' || state === 'completed') {
                        statusEl.textContent = 'âœ… Connected';
                    } else if (state === 'disconnected') {
                        statusEl.textContent = 'âš ï¸ Connection lost - Reconnecting...';
                    } else if (state === 'failed') {
                        statusEl.textContent = 'âŒ Connection failed';
                        stopStatsMonitoring();
                    } else if (state === 'checking') {
                        statusEl.textContent = 'ðŸ”„ Connecting...';
                    }
                };

                // Handle connection state
                peerConnection.onconnectionstatechange = () => {
                    console.log('Connection State:', peerConnection.connectionState);
                };

                // Handle ICE candidates
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log('Generated ICE candidate:', event.candidate.type);
                        sendIceCandidate(event.candidate);
                    } else {
                        console.log('ICE candidate gathering complete');
                    }
                };

                // Set remote description (offer)
                await peerConnection.setRemoteDescription({
                    type: 'offer',
                    sdp: data.sdp
                });
                console.log('Remote description (offer) set');

                // Create answer with optimized constraints
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                console.log('Local description (answer) set');

                // Send answer back to sender
                sendAnswer(answer);

            } catch (error) {
                console.error('Error handling offer:', error);
                statusEl.textContent = 'Error: ' + error.message;
            }
        }

        async function handleIceCandidate(data) {
            try {
                if (peerConnection) {
                    await peerConnection.addIceCandidate({
                        candidate: data.candidate,
                        sdpMid: data.sdpMid,
                        sdpMLineIndex: data.sdpMLineIndex
                    });
                    console.log('Added ICE candidate from sender');
                }
            } catch (error) {
                console.error('Error adding ICE candidate:', error);
            }
        }

        function sendAnswer(answer) {
            try {
                const message = JSON.stringify({
                    type: 'answer',
                    sdp: answer.sdp
                });
                context.sendCustomMessage(NAMESPACE, undefined, message);
                console.log('âœ“ Sent WebRTC answer');
            } catch (error) {
                console.error('Error sending answer:', error);
            }
        }

        function sendIceCandidate(candidate) {
            try {
                const message = JSON.stringify({
                    type: 'ice_candidate',
                    candidate: candidate.candidate,
                    sdpMid: candidate.sdpMid,
                    sdpMLineIndex: candidate.sdpMLineIndex
                });
                context.sendCustomMessage(NAMESPACE, undefined, message);
            } catch (error) {
                console.error('Error sending ICE candidate:', error);
            }
        }

        function startStatsMonitoring() {
            if (statsInterval) return;

            statsInterval = setInterval(async () => {
                if (!peerConnection) return;

                try {
                    const stats = await peerConnection.getStats();
                    let fps = 0;
                    let bitrate = 0;
                    let resolution = '';
                    let packetsLost = 0;
                    let jitter = 0;

                    stats.forEach(report => {
                        if (report.type === 'inbound-rtp' && report.mediaType === 'video') {
                            fps = report.framesPerSecond || 0;
                            packetsLost = report.packetsLost || 0;
                            jitter = report.jitter || 0;
                            
                            // Calculate bitrate
                            const now = Date.now();
                            const timeDiff = (now - lastTimestamp) / 1000;
                            const bytesDiff = (report.bytesReceived || 0) - lastBytesReceived;
                            bitrate = Math.round((bytesDiff * 8) / timeDiff / 1000); // Kbps
                            
                            lastBytesReceived = report.bytesReceived || 0;
                            lastTimestamp = now;
                        }
                        if (report.type === 'track' && report.kind === 'video') {
                            resolution = `${report.frameWidth}x${report.frameHeight}`;
                        }
                    });

                    statsEl.innerHTML = `
                        FPS: ${fps.toFixed(0)} | Bitrate: ${bitrate} Kbps<br>
                        Resolution: ${resolution}<br>
                        Packets Lost: ${packetsLost} | Jitter: ${jitter.toFixed(3)}s
                    `;
                } catch (error) {
                    console.error('Error getting stats:', error);
                }
            }, 1000);
        }

        function stopStatsMonitoring() {
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
        }

        // System events
        context.addEventListener(
            cast.framework.system.EventType.SENDER_CONNECTED,
            function(event) {
                console.log('Sender connected:', event.senderId);
                statusEl.textContent = 'Device Connected - Waiting for WebRTC...';
            }
        );

        context.addEventListener(
            cast.framework.system.EventType.SENDER_DISCONNECTED,
            function(event) {
                console.log('Sender disconnected');
                statusEl.textContent = 'Device Disconnected';
                statsEl.textContent = '';
                remoteVideo.srcObject = null;

                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
                stopStatsMonitoring();
            }
        );

        context.addEventListener(
            cast.framework.system.EventType.READY,
            function(event) {
                console.log('Receiver ready');
                statusEl.textContent = 'Ready - Waiting for connection...';
            }
        );

        context.addEventListener(
            cast.framework.system.EventType.ERROR,
            function(event) {
                console.error('Cast Receiver Error:', event);
                statusEl.textContent = 'Error: ' + event.error;
            }
        );

        // Start receiver
        try {
            context.start(castReceiverOptions);
            console.log('=== WebRTC Cast receiver started ===');
        } catch (error) {
            console.error('=== FAILED to start receiver ===', error);
            statusEl.textContent = 'FAILED TO START: ' + error.message;
            document.body.style.backgroundColor = 'red';
        }
    </script>
</body>
</html>
