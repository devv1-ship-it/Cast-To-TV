<script src="https://www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
<script>
    const statusEl = document.getElementById('status');
    const remoteVideo = document.getElementById('remoteVideo');
    const NAMESPACE = 'urn:x-cast:com.xxx.screenmirroring';
    let peerConnection = null;
    let context = cast.framework.CastReceiverContext.getInstance();

    // --- Add Event Listeners to the Video Element ---
    // These will tell us if the video element itself is having problems.
    remoteVideo.addEventListener('playing', () => { statusEl.textContent = '[Video Event: PLAYING]'; });
    remoteVideo.addEventListener('waiting', () => { statusEl.textContent = '[Video Event: WAITING FOR DATA...]'; });
    remoteVideo.addEventListener('error', () => { statusEl.textContent = '[FATAL: VIDEO ELEMENT ERROR!]'; });
    remoteVideo.addEventListener('stalled', () => { statusEl.textContent = '[Video Event: STALLED]'; });


    // --- Main Receiver Logic ---
    const castReceiverOptions = new cast.framework.CastReceiverOptions();
    castReceiverOptions.disableIdleTimeout = true;
    castReceiverOptions.maxInactivity = 3600;

    context.addCustomMessageListener(NAMESPACE, function(customEvent) {
        try {
            let data = customEvent.data;
            if (typeof data === 'string') {
                data = JSON.parse(data);
            }

            if (data.type === 'offer') {
                handleOffer(data);
            } else if (data.type === 'ice_candidate') {
                handleIceCandidate(data);
            } else if (data.type === 'audio') {
                // We'll keep the audio logic simple for now to focus on video
                // console.log("Audio packet received");
            }
        } catch (e) {
            statusEl.textContent = '[ERROR: JSON.parse failed]';
        }
    });

    context.addEventListener(cast.framework.system.EventType.SENDER_DISCONNECTED, () => {
        statusEl.textContent = 'Disconnected';
        if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
        }
        remoteVideo.srcObject = null;
    });

    context.start(castReceiverOptions);

    async function handleOffer(data) {
        try {
            statusEl.textContent = '[Offer Received]';
            const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
            peerConnection = new RTCPeerConnection(configuration);

            // --- DEBUG: Show every ICE connection state change on screen ---
            peerConnection.oniceconnectionstatechange = () => {
                statusEl.textContent = '[ICE State: ' + peerConnection.iceConnectionState + ']';
                console.log('ICE state:', peerConnection.iceConnectionState);
            };

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    sendMessage({
                        type: 'ice_candidate',
                        candidate: event.candidate.candidate,
                        sdpMid: event.candidate.sdpMid,
                        sdpMLineIndex: event.candidate.sdpMLineIndex
                    });
                }
            };

            // --- This is the MOST IMPORTANT part for debugging the black screen ---
            peerConnection.ontrack = (event) => {
                statusEl.textContent = '[Track Received: ' + event.track.kind + ']';
                
                if (event.streams && event.streams[0]) {
                    statusEl.textContent = '[Binding Stream to Video Element...]';
                    remoteVideo.srcObject = event.streams[0];

                    // Attempt to play and report success or failure
                    remoteVideo.play().then(() => {
                        statusEl.textContent = '[SUCCESS: Video Playback Started!]';
                    }).catch(e => {
                        statusEl.textContent = '[PLAY FAILED: ' + e.message + ']';
                    });

                } else {
                    statusEl.textContent = '[ERROR: Track event had no stream!]';
                }
            };

            await peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp: data.sdp }));
            statusEl.textContent = '[Remote Description Set]';
            
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            statusEl.textContent = '[Answer Created]';
            
            sendMessage({ type: 'answer', sdp: answer.sdp });

        } catch (e) {
            statusEl.textContent = '[FATAL OFFER ERROR: ' + e.message + ']';
        }
    }

    async function handleIceCandidate(data) {
        try {
            if (peerConnection && data.candidate) {
                await peerConnection.addIceCandidate(new RTCIceCandidate(data));
            }
        } catch (e) { console.error('ICE candidate error:', e); }
    }

    function sendMessage(messageObject) {
        try {
            const messageStr = JSON.stringify(messageObject);
            context.sendCustomMessage(NAMESPACE, undefined, messageStr);
        } catch (e) { console.error('Send message error:', e); }
    }
</script>
